# RPC消息解析

网络通信中，双端通信需要基于事先制定的通信协议。协议当中会约定双端如何进行数据的序列化和反序列化，即发送端如何把具有一定结构的对象转换为有序字节流，接收端如何从中反序列化得到原始对象。业界流行的方法有json、msgpack、protobuf等。而现在，我们自定义了一种协议描述文本来完成该功能。

下面是一些序列化协议的定义参考；可以**直接自定定义序列化语法，但请在解决方案文档中说明清楚**
## 协议描述和文本定义

协议描述文本表示大致如下：
{
	变量类型 变量名;
	...
	变量类型 变量名;
}
协议描述文本符合以下规则：
1. 以“{”开始，“}”结束；
2. 由若干个字段组成，每个字段依次由变量类型、变量名构成，可表示为“变量类型 变量名;”
3. 基本变量类型和变量名之间，至少存在1个空格，其他情况下变量类型和变量名之间可存在零或多个空格；
4. 每个字段以分号“;”结尾，分号前可以存在零或多个空格；
5. 字段和字段之间可能存在换行符、制表符、空格。
6. 变量名的命名规则符合C语言规范。
协议描述文本举例:
```cpp
{
    string name;
    int32  id  ;
    uint16 level;
}
```
表示依次有name、id、level三个字段，“;”为字段结束标记。

## 变量类型定义
变量类型分为基本类型和组合类型；基本类型和组合类型也可以有其对应的数组类型。

## 基本类型
所支持的基本类型见下表：

|类型标识	|含义	|字节数|
|:---:|:---:|:---:|
|int8|8位有符号整数|1|
|uint8|8位无符号整数|1|
|int16|16位有符号整数|2|
|uint16|16位无符号整数|2|
|int32|32位有符号整数|4|
|uint32|32位无符号整数|4|
|float|单精度浮点|4|
|double|双精度浮点|8|
|bool|布尔（1真0假）|1|
|string|字符串|2+L|
- 表中L为字符串长度（不超过65535），本身占2字节；字符串内容为utf-8编码。

## 组合类型

组合类型是若干个任意类型字段的组合体，协议描述定义本身也是一个组合类型。组合类型类似于C语言中的结构体，以“{”开始，“}”结束，中间可包括一个或者多个字段。
例如:
```c++
{
   {
       int32 id;
       string name;
   } pet;
   string name;
}
```
pet字段就是一个组合类型，它里面包含了id和name字段。
组合类型可嵌套，即组合类型中的字段也可以是一个组合类型。例如:
```c++
{
    {
       string name;
       int32 id    ;
       {
           string name;
           int32 id;
           {
               int32 id;
               string name;
           } skill;
       }pet;
       uint16 level;
    } player;
}
```
组合类型player中除了包含name、id、level基本类型定义的字段，
还包含pet组合类型字段，而pet组合类型也包含skill组合类型字段。
## 数组

可以用数组标识“[]”为基本/组合类型定义其数组；数组分两种：
1. 变长数组，表示为T[]，T表示变量类型；
2. 定长数组，表示为T[N]，T表示变量类型，N为正整数常量。
 变长数组意味着其长度并非在描述文本中事先确定，而是通过序列化的数据表达（16位无符号整数），其长度不会超过65535；一些例子：

```c++
int16[5] x; //x为5个int16元素构成的数组
string[] strs; //strs为元素个数不确定的字符串数组
{               
    bool flag;
    string name;
    int32 id;
}[] AoS;        //AoS为若干个struct构成的数组
```

- 注意：数组限定一维，不需要考虑多维数组情况。


## 序列化规则

1. 结构化对象的每个字段以协议描述文本中出现的顺序依次序列化。
2. 每种基本类型的数值遵循C语言规范的小端格式（little-endian）序列化为二进制数据，详情请见 https://en.wikipedia.org/wiki/Endianness
3. 除了变长数组和字符串，类型信息本身不会被序列化。
4. 对于字符串，其长度值作为uint16数值被序列化，然后按字符串头到尾的顺序对每个字符进行序列化。
5. 对于变长数组，其长度值作为uint16数值被序列化，然后按数组头到尾的顺序对每个数组元素进行序列化。
6. 组合类型的序列化是紧凑的，即不需要考虑字段间字节对齐问题而产生padding。
举例：
string a;
uint16[] b; 
float[2] c;
bool f;
假如a为"hello"，b有3个元素，依次为12, 64, 1025，c的2个元素依次为12.5, -33.4，f为真，
序列化结果字符串用16进制表示，则a的长度5和内容的序列化结果依次为'0500'、 '68656c6c6f'，
b的长度3和各元素的结果依次为'0300'、'0c00'、 '4000'、'0104'，c的结果依次为'00004841'、'9a9905c2'，
f的结果为'01'，故总的序列化结果为'050068656c6c6f03000c0040000104000048419a9905c201'。


##  具体要求和限制：
1. 简单的文本语法解析。
2. 实现序列化与反序列化要求。
3. 支持至少3种序列化数据压缩方法。
4. 使用至少三种设计模式。
5. 提供完善的文档代码注释和文件结构，个人解决方案文件夹中提供solution.md解决说明。
6. 只能使用C++标准库和系统API；禁止使用boost等第三放方库。
7. 独立完成作业，严禁抄袭。


## 简单测试用例
测试用例1:

```c++
{
   string name;    
   int32 id;        
   bool married;    
   int32[] friends;
   float[3] position;
   {
     string name;
     {
        uint16 id;   
     }[2] skill;
   } pet;
}
```
序列化数据传输实例:
```json
{
	"name": "测试数据",
	"id": 5201314,
	"married": False,
	"friends": (5201315, 244578811),
	"position": (134.5, 0.0, 23.41),
	"pet": {
		"name": "测试pet名称",
		"skill":(
			{
				"id": 1,
			},
			{
				"id": 2,
			}
        )
	}
}
```